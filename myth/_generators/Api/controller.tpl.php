<?php 

echo "<?php

/**
 * {$class_name} API Endpoints
 *
 * Auto-generated by Sprint on {$today}
 */
class {$class_name} extends \\Myth\\Api\\Server\\ApiController {

	/**
	 * Turns rate limiting on/off for this resource.
	 *
	 * @var
	 */
	protected \$enable_rate_limits = false;

	/**
	 * The number of requests allowed per user/hour
	 *
	 * @var int
	 */
	protected \$rate_limits = 0;

	/**
	 * The model file used for this resource.
	 *
	 * @var string
	 */
	protected \$model_file = '{$model_name}';

    /**
	 * The language file used for this resource.
	 *
	 * @var string
	 */
	protected \$language_file = 'api_{$plural}';

	/**
	 * The fields used by the formatter.
	 *
	 * @var
	 */
	protected \$fields;

	/**
	 * The ID field used to grab
	 * objects from the model.
	 *
	 * @var string
	 */
	protected \$primary_key = 'id';

	/**
	 * The version string for this API.
	 * Represents the folder name and URI segment.
	 *
	 * @var string
	 */
	protected \$api_version = '{$version}';

	//--------------------------------------------------------------------

	public function __construct()
	{
	    parent::__construct();

		/**
		 * Currently, only ensures that the user has authenticated.
		 */
		if (\$this->do_auth_check) {
			\$this->restrict();
		}
	}

	//--------------------------------------------------------------------

	/**
	 * Provides information about this resource to the end user in the
	 * form of:
	 *
	 *  - JSON description of each method (Optional, not here by default)
	 *  - set headers ALLOW tag.
	 *
	 * This is called via an OPTIONS call to the resource
	 */
	public function index()
	{
		// Tell the caller what actions are allowed on this resource.
		// If you change any of the routing types to LIMIT the actions
		// that can be taken on this resource (no PUT or DELETE, for
		// example) you must update this as well.
		\$this->output->set_header('Allow: GET, POST, PUT, DELETE, OPTIONS', true);

		// The spec says it cannot be cached, so ensure that....
		\$this->output->set_header('Cache-Control: no-cache, no-store, must-revalidate'); // HTTP 1.1.
		\$this->output->set_header('Pragma: no-cache'); // HTTP 1.0.
		\$this->output->set_header('Expires: 0'); // Proxies.

		// Mark the request as valid
		\$this->output->set_status_header(200);
	}

	//--------------------------------------------------------------------



	/**
	 * Returns a paginated list of the resource items.
	 *
	 * @return array
	 */
	public function list_all()
	{
		if (\$this->per_page > 0)
		{
			\$this->{$model_name}->limit(\$this->per_page, \$this->offset);
		}

		\${$plural} = \$this->{$model_name}->as_array()->find_all();

		// Valid Results?
		if (! \${$plural} || (is_array(\${$plural}) && ! count(\${$plural})) )
		{
			return \$this->failNotFound( lang('resource_not_found') );
		}

		\$new_{$plural} = [];

		array_walk(\${$plural}, function (\${$single}, \$key) use (&\$new_{$plural}) {
			\$new_{$plural}[] = \$this->formatResource(\${$single});
		});

		\$total = \$this->{$model_name}->count_by(['deleted' => 0]);

		\$first = \$this->offset > 0 ? \$this->offset : \$this->offset + 1;
		\$last  = \$this->offset + count(\${$plural});

		\$return = [
			'total' => \$total,
			'first' => \$first,
			'last'  => \$last,
			'prev_url'  => \$total <= \$this->per_page ? null :  \$this->prevURL('v1/users'),
			'next_url'  => \$total <= \$this->per_page ? null :  \$this->nextURL('v1/users'),
			'users' => \$new_{$plural}
		];

		\$this->respond(\$return);
	}

	//--------------------------------------------------------------------

	/**
	 * Handles creating a new resource.
	 */
	public function create() 
	{
	    // You should put code here to check whether the
		// resource already exists in the database or not.
		// Or let the validation in the model handle it, I guess.
		\$exists = false;

		if (\$exists)
		{
			return \$this->failResourceExists( lang('resource_exists') );
		}

		// The model's default insert() method will automatically prep the data
		// and remove any extra fields that might be in the \$_POST array.
		\$post_data = \$this->input->post();

		if (! \$id = \$this->{$model_name}->insert(\$post_data))
		{
			// The model will load the form validation library.
			if (validation_errors() )
			{
				return \$this->failValidationError( validation_errors() );
			}

			return \$this->fail( lang('cannot_create_resource'), 500);
		}

		// Now we'll return the new resource, but we grab from the database
		// in case any observers modified data on the way in.
		\${$single} = \$this->{$model_name}->find_by(\$this->primary_key, \$id);

		\$this->respondCreated(\${$single});
	}
	
	//--------------------------------------------------------------------

	/**
	 * Gets the details for a single User
	 * 
	 * @param \$id
	 *
	 * @return array
	 */
	public function show(\$id)
	{
	    \${$single} = \$this->{$model_name}->with_deleted()
		                         ->as_array()
		                         ->find_by(\$this->primary_key, \$id);

		// Valid user?
		if (! \${$single})
		{
			return \$this->failNotFound( lang('resource_not_found') );
		}

		if (\${$single}['deleted'] == 1)
		{
			return \$this->failResourceGone( lang('resource_gone') );
		}

		\$this->respond( \$this->formatResource(\${$single}) );
	}
	
	//--------------------------------------------------------------------

	/**
	 * Updates a single resource.
	 *
	 * @param \$id
	 *
	 * @return mixed
	 */
	public function update(\$id)
	{
	    // Does this resource already exist?
		if (\$this->{$model_name}->is_unique(\$this->primary_key, \$id))
		{
			return \$this->failNotFound( lang('resource_not_found') );
		}

		\$post_data = \$this->input->post();

		if (! count(\$post_data))
		{
			return \$this->failBadRequest( lang('resource_bad_data') );
		}

		if (! \$this->{$model_name}->update(\$id, \$post_data))
		{
			if ( validation_errors() )
			{
				return \$this->failValidationError( validation_errors() );
			}

			return \$this->fail( lang('cannot_update_resource'), 500);
		}

		// Now we'll return the new resource, but we grab from the database
		// in case any observers modified data on the way in.
		\${$single} = \$this->{$model_name}->find_by(\$this->primary_key, \$id);

		\$this->respond(\${$single}, 200);
	}
	
	//--------------------------------------------------------------------

	/**
	 * Deletes a single resource.
	 *
	 * @param \$id
	 *
	 * @return mixed
	 */
	public function destroy(\$id)
	{
	    if (\$this->{$model_name}->is_unique(\$this->primary_key, \$id))
	    {
		    return \$this->failNotFound( lang('resource_not_found') );
	    }

		if (! \$this->{$model_name}->delete_by(\$this->primary_key, \$id))
		{
			return \$this->fail( lang('resource_unknown_db_err'), 500);
		}

		\$this->respondDeleted(['response' => lang('resource_did_delete') ]);
	}
	
	//--------------------------------------------------------------------

	//--------------------------------------------------------------------
	// Utility Methods
	//--------------------------------------------------------------------

	/**
	 * Handles formatting a resource in a default manner. Helps to ensure
	 * consistent formatting. If customization is needed, it will need
	 * to be done by the method itself, after standardizing the format.
	 *
	 * THIS IS A GENERIC METHOD AND SHOULD BE CUSTOMIZED TO FIT YOUR NEEDS!
	 *
	 * @param array \$resource
	 *
	 * @return array
	 */
	private function formatResource( array \$resource )
	{
		if (empty(\$this->fields))
		{
			if (! empty(\$this->selects))
			{
				\$this->fields = \$this->selects;
			}
			else
			{
				\$this->fields = \$this->{$model_name}->get_fields();
			}
		}

		\$new_resource = [];

		foreach (\$this->fields as \$field)
		{
			\$new_resource[\$field] = array_key_exists(\$field, \$resource) ? \$resource[\$field] : null;
		}

		\$new_resource['meta'] = [
			'url' => site_url(\"{\$this->api_version}/{$plural}/{\$resource[\$this->primary_key]}\")
		];

		return \$new_resource;
	}

	//--------------------------------------------------------------------


}
";